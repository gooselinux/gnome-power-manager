From 4d5ed37e24761f6b83f531166440ac311a5f95eb Mon Sep 17 00:00:00 2001
From: Bastien Nocera <hadess@hadess.net>
Date: Tue, 27 Oct 2009 23:33:46 +0000
Subject: [PATCH] Use gnome-settings-daemon popup code

Instead of forking it.

Also make sure the location of the popup matches
that used by gnome-settings-daemon, and we switch
styles when switching compositing on/off.

https://bugzilla.gnome.org/show_bug.cgi?id=594664
---
 data/Makefile.am            |    3 +-
 data/acme.ui                |   41 ++
 src/Makefile.am             |    5 +-
 src/gpm-backlight.c         |  111 ++++-
 src/gpm-popup-window.c      |  725 ----------------------------
 src/gpm-popup-window.h      |   61 ---
 src/gsd-media-keys-window.c | 1109 +++++++++++++++++++++++++++++++++++++++++++
 src/gsd-media-keys-window.h |   69 +++
 8 files changed, 1325 insertions(+), 799 deletions(-)
 create mode 100644 data/acme.ui
 delete mode 100644 src/gpm-popup-window.c
 delete mode 100644 src/gpm-popup-window.h
 create mode 100644 src/gsd-media-keys-window.c
 create mode 100644 src/gsd-media-keys-window.h

diff --git a/data/Makefile.am b/data/Makefile.am
index 1a76ac8..99df812 100644
--- a/data/Makefile.am
+++ b/data/Makefile.am
@@ -26,7 +26,8 @@ $(service_DATA): $(service_in_files) Makefile
 pkgdata_DATA =						\
 	gpm-statistics.ui				\
 	gpm-feedback-widget.ui				\
-	gpm-prefs.ui
+	gpm-prefs.ui					\
+	acme.ui
 
 EXTRA_DIST =						\
 	gnome-power-manager.schemas.in			\
diff --git a/data/acme.ui b/data/acme.ui
new file mode 100644
index 0000000..3222ecb
--- /dev/null
+++ b/data/acme.ui
@@ -0,0 +1,41 @@
+<?xml version="1.0"?>
+<interface>
+  <!-- interface-requires gtk+ 2.6 -->
+  <!-- interface-naming-policy toplevel-contextual -->
+  <object class="GtkWindow" id="dialog">
+    <child>
+      <object class="GtkFrame" id="acme_frame">
+        <property name="visible">True</property>
+        <property name="label_xalign">0</property>
+        <property name="shadow_type">out</property>
+        <child>
+          <object class="GtkVBox" id="acme_vbox">
+            <property name="visible">True</property>
+            <property name="border_width">12</property>
+            <property name="spacing">6</property>
+            <child>
+              <object class="GtkImage" id="acme_image">
+                <property name="visible">True</property>
+                <property name="icon_name">audio-volume-high</property>
+                <property name="icon-size">6</property>
+              </object>
+              <packing>
+                <property name="position">0</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkProgressBar" id="acme_volume_progressbar">
+                <property name="visible">True</property>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+                <property name="fill">False</property>
+                <property name="position">1</property>
+              </packing>
+            </child>
+          </object>
+        </child>
+      </object>
+    </child>
+  </object>
+</interface>
diff --git a/src/Makefile.am b/src/Makefile.am
index b41da1f..b038669 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -28,6 +28,7 @@ INCLUDES =						\
 	-DLIBDIR=\""$(libdir)"\" 			\
 	-DVERSION="\"$(VERSION)\"" 			\
 	-DGPM_DATA=\"$(pkgdatadir)\"			\
+	-DGTKBUILDERDIR=\"$(pkgdatadir)\"		\
 	-DDKP_DISABLE_DEPRECATED			\
 	-DEGG_LOG_FILE=\""/tmp/gpm.log"\"		\
 	-DEGG_VERBOSE="\"GPM_VERBOSE\""			\
@@ -161,8 +162,8 @@ gnome_power_manager_SOURCES =				\
 	gpm-networkmanager.h				\
 	gpm-networkmanager.c				\
 	gpm-stock-icons.h				\
-	gpm-popup-window.h				\
-	gpm-popup-window.c				\
+	gsd-media-keys-window.h				\
+	gsd-media-keys-window.c				\
 	gpm-engine.h					\
 	gpm-engine.c					\
 	$(NULL)
diff --git a/src/gpm-backlight.c b/src/gpm-backlight.c
index 7714bcc..8c6c236 100644
--- a/src/gpm-backlight.c
+++ b/src/gpm-backlight.c
@@ -48,7 +48,7 @@
 #include "gpm-control.h"
 #include "gpm-common.h"
 #include "egg-debug.h"
-#include "gpm-popup-window.h"
+#include "gsd-media-keys-window.h"
 #include "gpm-dpms.h"
 #include "gpm-idle.h"
 #include "gpm-marshal.h"
@@ -167,6 +167,91 @@ gpm_backlight_set_brightness (GpmBacklight *backlight, guint percentage, GError
 }
 
 /**
+ * gpm_backlight_dialog_init:
+ *
+ * Initialises the popup, and makes sure that it matches the compositing of the screen.
+ **/
+static void
+gpm_backlight_dialog_init (GpmBacklight *backlight)
+{
+	if (backlight->priv->popup != NULL
+	    && !gsd_media_keys_window_is_valid (GSD_MEDIA_KEYS_WINDOW (backlight->priv->popup))) {
+		gtk_widget_destroy (backlight->priv->popup);
+		backlight->priv->popup = NULL;
+	}
+
+	if (backlight->priv->popup == NULL) {
+		backlight->priv->popup= gsd_media_keys_window_new ();
+		gsd_media_keys_window_set_action (GSD_MEDIA_KEYS_WINDOW (backlight->priv->popup),
+						  GSD_MEDIA_KEYS_WINDOW_ACTION_BRIGHTNESS);
+		gtk_window_set_position (GTK_WINDOW (backlight->priv->popup), GTK_WIN_POS_NONE);
+	}
+}
+
+/**
+ * gpm_backlight_dialog_show:
+ *
+ * Show the brightness popup, and place it nicely on the screen.
+ **/
+static void
+gpm_backlight_dialog_show (GpmBacklight *backlight)
+{
+	int            orig_w;
+	int            orig_h;
+	int            screen_w;
+	int            screen_h;
+	int            x;
+	int            y;
+	int            pointer_x;
+	int            pointer_y;
+	GtkRequisition win_req;
+	GdkScreen     *pointer_screen;
+	GdkRectangle   geometry;
+	int            monitor;
+
+	/*
+	 * get the window size
+	 * if the window hasn't been mapped, it doesn't necessarily
+	 * know its true size, yet, so we need to jump through hoops
+	 */
+	gtk_window_get_default_size (GTK_WINDOW (backlight->priv->popup), &orig_w, &orig_h);
+	gtk_widget_size_request (backlight->priv->popup, &win_req);
+
+	if (win_req.width > orig_w) {
+		orig_w = win_req.width;
+	}
+	if (win_req.height > orig_h) {
+		orig_h = win_req.height;
+	}
+
+	pointer_screen = NULL;
+	gdk_display_get_pointer (gtk_widget_get_display (backlight->priv->popup),
+				 &pointer_screen,
+				 &pointer_x,
+				 &pointer_y,
+				 NULL);
+	monitor = gdk_screen_get_monitor_at_point (pointer_screen,
+						   pointer_x,
+						   pointer_y);
+
+	gdk_screen_get_monitor_geometry (pointer_screen,
+					 monitor,
+					 &geometry);
+
+	screen_w = geometry.width;
+	screen_h = geometry.height;
+
+	x = ((screen_w - orig_w) / 2) + geometry.x;
+	y = geometry.y + (screen_h / 2) + (screen_h / 2 - orig_h) / 2;
+
+	gtk_window_move (GTK_WINDOW (backlight->priv->popup), x, y);
+
+	gtk_widget_show (backlight->priv->popup);
+
+	gdk_display_sync (gtk_widget_get_display (backlight->priv->popup));
+}
+
+/**
  * gpm_common_sum_scale:
  *
  * Finds the average between value1 and value2 set on a scale factor
@@ -261,8 +346,10 @@ gpm_backlight_brightness_evaluate_and_set (GpmBacklight *backlight, gboolean int
 
 	/* only show dialog if interactive */
 	if (interactive) {
-		gpm_popup_window_set_value (GPM_POPUP_WINDOW (backlight->priv->popup), (float) brightness);
-		gtk_widget_show (backlight->priv->popup);
+		gpm_backlight_dialog_init (backlight);
+		gsd_media_keys_window_set_volume_level (GSD_MEDIA_KEYS_WINDOW (backlight->priv->popup),
+							round (brightness));
+		gpm_backlight_dialog_show (backlight);
 	}
 
 	ret = gpm_brightness_set (backlight->priv->brightness, value, &hw_changed);
@@ -352,8 +439,10 @@ gpm_backlight_button_pressed_cb (GpmButton *button, const gchar *type, GpmBackli
 		/* show the new value */
 		if (ret) {
 			gpm_brightness_get (backlight->priv->brightness, &percentage);
-			gpm_popup_window_set_value (GPM_POPUP_WINDOW (backlight->priv->popup), (gfloat) percentage/100.0f);
-			gtk_widget_show (backlight->priv->popup);
+			gpm_backlight_dialog_init (backlight);
+			gsd_media_keys_window_set_volume_level (GSD_MEDIA_KEYS_WINDOW (backlight->priv->popup),
+								percentage);
+			gpm_backlight_dialog_show (backlight);
 			/* save the new percentage */
 			backlight->priv->master_percentage = percentage;
 		}
@@ -369,8 +458,10 @@ gpm_backlight_button_pressed_cb (GpmButton *button, const gchar *type, GpmBackli
 		/* show the new value */
 		if (ret) {
 			gpm_brightness_get (backlight->priv->brightness, &percentage);
-			gpm_popup_window_set_value (GPM_POPUP_WINDOW (backlight->priv->popup), (gfloat) percentage/100.0f);
-			gtk_widget_show (backlight->priv->popup);
+			gpm_backlight_dialog_init (backlight);
+			gsd_media_keys_window_set_volume_level (GSD_MEDIA_KEYS_WINDOW (backlight->priv->popup),
+								percentage);
+			gpm_backlight_dialog_show (backlight);
 			/* save the new percentage */
 			backlight->priv->master_percentage = percentage;
 		}
@@ -688,10 +779,10 @@ gpm_backlight_init (GpmBacklight *backlight)
 	gpm_idle_set_timeout_dim (backlight->priv->idle, backlight->priv->idle_dim_timeout);
 
 	/* use a visual widget */
-	backlight->priv->popup = gpm_popup_window_new ();
+	backlight->priv->popup = gsd_media_keys_window_new ();
+	gsd_media_keys_window_set_action (GSD_MEDIA_KEYS_WINDOW (backlight->priv->popup),
+					  GSD_MEDIA_KEYS_WINDOW_ACTION_BRIGHTNESS);
         gtk_window_set_position (GTK_WINDOW (backlight->priv->popup), GTK_WIN_POS_NONE);
-	gpm_popup_window_set_icon_name (GPM_POPUP_WINDOW (backlight->priv->popup),
-					GPM_STOCK_BRIGHTNESS_LCD);
 
 	/* DPMS mode poll class */
 	backlight->priv->dpms = gpm_dpms_new ();
diff --git a/src/gpm-popup-window.c b/src/gpm-popup-window.c
deleted file mode 100644
index 6cc4038..0000000
--- a/src/gpm-popup-window.c
+++ /dev/null
@@ -1,725 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2006-2007 William Jon McCann <mccann@jhu.edu>
- * Copyright (C) 2009 Richard Hughes <richard@hughsie.com>
- *
- * Licensed under the GNU General Public License Version 2
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#include "config.h"
-
-#include <math.h>
-#include <glib.h>
-#include <gtk/gtk.h>
-
-#include "egg-debug.h"
-
-#include "gpm-popup-window.h"
-
-#define GPM_POPUP_WINDOW_DIALOG_TIMEOUT		2000	/* dialog timeout in ms */
-#define GPM_POPUP_WINDOW_DIALOG_FADE_TIMEOUT	1500	/* timeout before fade starts */
-#define GPM_POPUP_WINDOW_FADE_TIMEOUT		10	/* timeout in ms between each frame of the fade */
-
-#define GPM_POPUP_WINDOW_BG_ALPHA		0.50
-#define GPM_POPUP_WINDOW_FG_ALPHA		1.00
-
-#define GPM_POPUP_WINDOW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GPM_TYPE_POPUP_WINDOW, GpmPopupWindowPrivate))
-
-struct GpmPopupWindowPrivate
-{
-	gboolean		 is_composited;
-	guint			 hide_timeout_id;
-	guint			 fade_timeout_id;
-	gdouble			 fade_out_alpha;
-	gfloat			 value;
-	gchar			*icon_name;
-	GtkImage		*image;
-	GtkWidget		*progress;
-	GtkWidget		*frame;
-};
-
-G_DEFINE_TYPE (GpmPopupWindow, gpm_popup_window, GTK_TYPE_WINDOW)
-
-/**
- * gpm_popup_window_fade_timeout_cb:
- **/
-static gboolean
-gpm_popup_window_fade_timeout_cb (GpmPopupWindow *popup)
-{
-	if (popup->priv->fade_out_alpha <= 0.0) {
-		gtk_widget_hide (GTK_WIDGET (popup));
-
-		/* Reset it for the next time */
-		popup->priv->fade_out_alpha = 1.0;
-		popup->priv->fade_timeout_id = 0;
-
-		return FALSE;
-	} else {
-		GdkRectangle rect;
-		GtkWidget *widget = GTK_WIDGET (popup);
-		GtkAllocation allocation;
-
-		popup->priv->fade_out_alpha -= 0.10;
-
-		rect.x = 0;
-		rect.y = 0;
-		gtk_widget_get_allocation (widget, &allocation);
-		rect.width = allocation.width;
-		rect.height = allocation.height;
-
-		gdk_window_invalidate_rect (gtk_widget_get_window (widget), &rect, FALSE);
-	}
-
-	return TRUE;
-}
-
-/**
- * gpm_popup_window_hide_timeout_cb:
- **/
-static gboolean
-gpm_popup_window_hide_timeout_cb (GpmPopupWindow *popup)
-{
-	if (popup->priv->is_composited) {
-		popup->priv->hide_timeout_id = 0;
-		popup->priv->fade_timeout_id = g_timeout_add (GPM_POPUP_WINDOW_FADE_TIMEOUT,
-							      (GSourceFunc) gpm_popup_window_fade_timeout_cb, popup);
-	} else {
-		gtk_widget_hide (GTK_WIDGET (popup));
-	}
-
-	return FALSE;
-}
-
-/**
- * gpm_popup_window_remove_hide_timeout:
- **/
-static void
-gpm_popup_window_remove_hide_timeout (GpmPopupWindow *popup)
-{
-	if (popup->priv->hide_timeout_id != 0) {
-		g_source_remove (popup->priv->hide_timeout_id);
-		popup->priv->hide_timeout_id = 0;
-	}
-
-	if (popup->priv->fade_timeout_id != 0) {
-		g_source_remove (popup->priv->fade_timeout_id);
-		popup->priv->fade_timeout_id = 0;
-		popup->priv->fade_out_alpha = 1.0;
-	}
-}
-
-/**
- * gpm_popup_window_add_hide_timeout:
- **/
-static void
-gpm_popup_window_add_hide_timeout (GpmPopupWindow *popup)
-{
-	guint timeout;
-	if (popup->priv->is_composited) {
-		timeout = GPM_POPUP_WINDOW_DIALOG_FADE_TIMEOUT;
-	} else {
-		timeout = GPM_POPUP_WINDOW_DIALOG_TIMEOUT;
-	}
-	popup->priv->hide_timeout_id = g_timeout_add (timeout, (GSourceFunc) gpm_popup_window_hide_timeout_cb, popup);
-}
-
-/**
- * gpm_popup_window_update_window:
- **/
-static void
-gpm_popup_window_update_window (GpmPopupWindow *popup)
-{
-	gpm_popup_window_remove_hide_timeout (popup);
-	gpm_popup_window_add_hide_timeout (popup);
-
-	if (popup->priv->is_composited)
-		gtk_widget_queue_draw (GTK_WIDGET (popup));
-}
-
-/**
- * gpm_popup_window_set_icon_name:
- **/
-void
-gpm_popup_window_set_icon_name (GpmPopupWindow *popup, const gchar *icon_name)
-{
-	g_return_if_fail (GPM_IS_POPUP_WINDOW (popup));
-	g_free (popup->priv->icon_name);
-	popup->priv->icon_name = g_strdup (icon_name);
-	if (popup->priv->image != NULL)
-		gtk_image_set_from_icon_name (popup->priv->image, icon_name, GTK_ICON_SIZE_DIALOG);
-}
-
-/**
- * gpm_popup_window_set_value:
- **/
-void
-gpm_popup_window_set_value (GpmPopupWindow *popup, gfloat level)
-{
-	g_return_if_fail (GPM_IS_POPUP_WINDOW (popup));
-
-	if (popup->priv->value != level) {
-		popup->priv->value = level;
-		gpm_popup_window_update_window (popup);
-
-		/* set value straight away */
-		if (!popup->priv->is_composited && popup->priv->progress != NULL)
-			gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (popup->priv->progress), popup->priv->value);
-	}
-}
-
-/**
- * gpm_popup_window_curved_rectangle:
- **/
-static void
-gpm_popup_window_curved_rectangle (cairo_t *cr, gdouble x, gdouble y, gdouble width, gdouble height, gdouble radius)
-{
-	gdouble xw;
-	gdouble yh;
-
-	xw = x + width;
-	yh = y + height;
-
-	if (!width || !height) {
-		goto out;
-	}
-
-	if (width / 2 < radius) {
-		if (height / 2 < radius) {
-			cairo_move_to (cr, x, (y + yh) / 2);
-			cairo_curve_to (cr, x ,y, x, y, (x + xw) / 2, y);
-			cairo_curve_to (cr, xw, y, xw, y, xw, (y + yh) / 2);
-			cairo_curve_to (cr, xw, yh, xw, yh, (xw + x) / 2, yh);
-			cairo_curve_to (cr, x, yh, x, yh, x, (y + yh) / 2);
-		} else {
-			cairo_move_to (cr, x, y + radius);
-			cairo_curve_to (cr, x, y, x, y, (x + xw) / 2, y);
-			cairo_curve_to (cr, xw, y, xw, y, xw, y + radius);
-			cairo_line_to (cr, xw, yh - radius);
-			cairo_curve_to (cr, xw, yh, xw, yh, (xw + x) / 2, yh);
-			cairo_curve_to (cr, x, yh, x, yh, x, yh - radius);
-		}
-	} else {
-		if (height / 2 < radius) {
-			cairo_move_to (cr, x, (y + yh) / 2);
-			cairo_curve_to (cr, x, y, x , y, x + radius, y);
-			cairo_line_to (cr, xw - radius, y);
-			cairo_curve_to (cr, xw, y, xw, y, xw, (y + yh) / 2);
-			cairo_curve_to (cr, xw, yh, xw, yh, xw - radius, yh);
-			cairo_line_to (cr, x + radius, yh);
-			cairo_curve_to (cr, x, yh, x, yh, x, (y + yh) / 2);
-		} else {
-			cairo_move_to (cr, x, y + radius);
-			cairo_curve_to (cr, x , y, x , y, x + radius, y);
-			cairo_line_to (cr, xw - radius, y);
-			cairo_curve_to (cr, xw, y, xw, y, xw, y + radius);
-			cairo_line_to (cr, xw, yh - radius);
-			cairo_curve_to (cr, xw, yh, xw, yh, xw - radius, yh);
-			cairo_line_to (cr, x + radius, yh);
-			cairo_curve_to (cr, x, yh, x, yh, x, yh - radius);
-		}
-	}
-out:
-	cairo_close_path (cr);
-}
-
-/**
- * gpm_popup_window_load_pixbuf:
- **/
-static GdkPixbuf *
-gpm_popup_window_load_pixbuf (GpmPopupWindow *popup, const gchar *icon_name, gint icon_size)
-{
-	GtkIconTheme *theme;
-	GdkPixbuf *pixbuf = NULL;
-	guint width;
-
-	if (icon_name == NULL)
-		goto out;
-
-	egg_debug ("rendering %s to a pixbuf", icon_name); 
-	if (popup != NULL && gtk_widget_has_screen (GTK_WIDGET (popup))) {
-		theme = gtk_icon_theme_get_for_screen (gtk_widget_get_screen (GTK_WIDGET (popup)));
-	} else {
-		theme = gtk_icon_theme_get_default ();
-	}
-
-	/* make sure the pixbuf is close to the requested size
-	 * this is necessary because GTK_ICON_LOOKUP_FORCE_SVG
-	 * seems to be broken */
-	pixbuf = gtk_icon_theme_load_icon (theme, icon_name, icon_size, GTK_ICON_LOOKUP_FORCE_SVG, NULL);
-	if (pixbuf != NULL) {
-		width = gdk_pixbuf_get_width (pixbuf);
-		if (width < (float)icon_size * 0.75) {
-			g_object_unref (pixbuf);
-			pixbuf = NULL;
-		}
-	}
-out:
-	return pixbuf;
-}
-
-/**
- * gpm_popup_window_render_icon:
- **/
-static gboolean
-gpm_popup_window_render_icon (GpmPopupWindow *popup, cairo_t *cr, gdouble x, gdouble y, gdouble width, gdouble height)
-{
-	GdkPixbuf *pixbuf;
-
-	/* get pixbuf */
-	pixbuf = gpm_popup_window_load_pixbuf (popup, popup->priv->icon_name, (gint) width);
-	if (pixbuf == NULL)
-		return FALSE;
-
-	/* render */
-	gdk_cairo_set_source_pixbuf (cr, pixbuf, x, y);
-	cairo_paint_with_alpha (cr, GPM_POPUP_WINDOW_FG_ALPHA);
-
-	g_object_unref (pixbuf);
-	return TRUE;
-}
-
-/**
- * gpm_popup_window_draw_progress_bar:
- **/
-static void
-gpm_popup_window_draw_progress_bar (GpmPopupWindow *popup, cairo_t *cr, gdouble percentage,
-				    gdouble x, gdouble y, gdouble width, gdouble height)
-{
-	gdouble xw;
-	GdkColor color;
-	gdouble r, g, b;
-
-	xw = width * percentage;
-
-	/* bar background */
-	color = gtk_widget_get_style (GTK_WIDGET (popup))->dark [GTK_STATE_NORMAL];
-	r = (float)color.red / 65535.0;
-	g = (float)color.green / 65535.0;
-	b = (float)color.blue / 65535.0;
-	cairo_rectangle (cr, x, y, width, height);
-	cairo_set_source_rgba (cr, r, g, b, GPM_POPUP_WINDOW_FG_ALPHA);
-	cairo_fill (cr);
-
-	/* bar border */
-	color = gtk_widget_get_style (GTK_WIDGET (popup))->dark [GTK_STATE_SELECTED];
-	r = (float)color.red / 65535.0;
-	g = (float)color.green / 65535.0;
-	b = (float)color.blue / 65535.0;
-	cairo_rectangle (cr, x, y, width, height);
-	cairo_set_source_rgba (cr, r, g, b, GPM_POPUP_WINDOW_FG_ALPHA);
-	cairo_set_line_width (cr, 1);
-	cairo_stroke (cr);
-
-	/* bar progress */
-	color = gtk_widget_get_style (GTK_WIDGET (popup))->bg [GTK_STATE_SELECTED];
-	r = (float)color.red / 65535.0;
-	g = (float)color.green / 65535.0;
-	b = (float)color.blue / 65535.0;
-	cairo_rectangle (cr, x, y, xw, height);
-	cairo_set_source_rgba (cr, r, g, b, GPM_POPUP_WINDOW_FG_ALPHA);
-	cairo_fill (cr);
-}
-
-/**
- * gpm_popup_window_draw_action:
- **/
-static void
-gpm_popup_window_draw_action (GpmPopupWindow *popup, cairo_t *cr)
-{
-	gint window_width;
-	gint window_height;
-	gdouble icon_box_width;
-	gdouble icon_box_height;
-	gdouble icon_box_x;
-	gdouble icon_box_y;
-	gdouble value_box_x;
-	gdouble value_box_y;
-	gdouble value_box_width;
-	gdouble value_box_height;
-	gboolean ret;
-
-	gtk_window_get_size (GTK_WINDOW (popup), &window_width, &window_height);
-
-	icon_box_width = window_width * 0.65;
-	icon_box_height = window_height * 0.65;
-	value_box_width = icon_box_width;
-	value_box_height = window_height * 0.05;
-
-	icon_box_x = (window_width - icon_box_width) / 2;
-	icon_box_y = (window_height - icon_box_height - value_box_height) / 2;
-	value_box_x = icon_box_x;
-	value_box_y = icon_box_height + icon_box_y;
-
-	ret = gpm_popup_window_render_icon (popup, cr, icon_box_x, icon_box_y, icon_box_width, icon_box_height);
-	if (!ret)
-		egg_warning ("failed to render");
-
-	/* draw progress bar */
-	gpm_popup_window_draw_progress_bar (popup, cr, popup->priv->value,
-					    value_box_x, value_box_y,
-					    value_box_width, value_box_height);
-}
-
-/**
- * gpm_popup_window_expose_event_cb:
- **/
-static gboolean
-gpm_popup_window_expose_event_cb (GtkWidget *widget, GdkEventExpose *event, GpmPopupWindow *popup)
-{
-	cairo_t *context;
-	cairo_t *cr;
-	cairo_surface_t *surface;
-	gint width;
-	gint height;
-	GdkColor color;
-	gdouble r, g, b;
-
-	/* ignore for non-composite windows */
-	if (!popup->priv->is_composited)
-		goto out;
-
-	context = gdk_cairo_create (gtk_widget_get_window (GTK_WIDGET (popup)));
-
-	cairo_set_operator (context, CAIRO_OPERATOR_SOURCE);
-	gtk_window_get_size (GTK_WINDOW (widget), &width, &height);
-
-	surface = cairo_surface_create_similar (cairo_get_target (context),
-						CAIRO_CONTENT_COLOR_ALPHA,
-						width, height);
-
-	if (cairo_surface_status (surface) != CAIRO_STATUS_SUCCESS)
-		goto done;
-
-	cr = cairo_create (surface);
-	if (cairo_status (cr) != CAIRO_STATUS_SUCCESS)
-		goto done;
-
-	cairo_set_source_rgba (cr, 1.0, 1.0, 1.0, 0.0);
-	cairo_set_operator (cr, CAIRO_OPERATOR_OVER);
-	cairo_paint (cr);
-
-	/* draw a box */
-	gpm_popup_window_curved_rectangle (cr, 0.5, 0.5, width-1, height-1, height / 10);
-	color = gtk_widget_get_style (GTK_WIDGET (popup))->bg [GTK_STATE_NORMAL];
-	r = (float)color.red / 65535.0;
-	g = (float)color.green / 65535.0;
-	b = (float)color.blue / 65535.0;
-	cairo_set_source_rgba (cr, r, g, b, GPM_POPUP_WINDOW_BG_ALPHA);
-	cairo_fill_preserve (cr);
-
-	color = gtk_widget_get_style (GTK_WIDGET (popup))->fg [GTK_STATE_NORMAL];
-	r = (float)color.red / 65535.0;
-	g = (float)color.green / 65535.0;
-	b = (float)color.blue / 65535.0;
-	cairo_set_source_rgba (cr, r, g, b, GPM_POPUP_WINDOW_BG_ALPHA);
-	cairo_set_line_width (cr, 1);
-	cairo_stroke (cr);
-
-	/* draw action */
-	gpm_popup_window_draw_action (popup, cr);
-
-	cairo_destroy (cr);
-
-	/* Make sure we have a transparent background */
-	cairo_rectangle (context, 0, 0, width, height);
-	cairo_set_source_rgba (context, 0.0, 0.0, 0.0, 0.0);
-	cairo_fill (context);
-
-	cairo_set_source_surface (context, surface, 0, 0);
-	cairo_paint_with_alpha (context, popup->priv->fade_out_alpha);
-
-done:
-	if (surface != NULL)
-		cairo_surface_destroy (surface);
-	cairo_destroy (context);
-out:
-	return FALSE;
-}
-
-/**
- * gpm_popup_window_move_to_screen_base:
- **/
-static void
-gpm_popup_window_move_to_screen_base (GtkWidget *widget)
-{
-	gint orig_w, orig_h;
-	gint screen_w, screen_h;
-	gint x, y;
-	gint pointer_x, pointer_y;
-	GtkRequisition widget_req;
-	GdkScreen *pointer_screen = NULL;
-	GdkRectangle geometry;
-	gint monitor = 0;
-	GdkScreen *current_screen;
-
-	current_screen = gdk_screen_get_default ();
-	gtk_window_set_screen (GTK_WINDOW (widget), current_screen);
-
-	/* get the window size - if the window hasn't been mapped, it doesn't
-	 * necessarily know its true size, yet, so we need to jump through hoops */
-	gtk_window_get_default_size (GTK_WINDOW (widget), &orig_w, &orig_h);
-	gtk_widget_size_request (widget, &widget_req);
-
-	if (widget_req.width > orig_w)
-		orig_w = widget_req.width;
-	if (widget_req.height > orig_h)
-		orig_h = widget_req.height;
-
-	gdk_display_get_pointer (gdk_screen_get_display (current_screen),
-				 &pointer_screen, &pointer_x, &pointer_y, NULL);
-	/* is the pointer is on the current screen */
-	if (pointer_screen == current_screen)
-		monitor = gdk_screen_get_monitor_at_point (current_screen, pointer_x, pointer_y);
-
-	/* get monitor size */
-	gdk_screen_get_monitor_geometry (current_screen, monitor, &geometry);
-	screen_w = geometry.width;
-	screen_h = geometry.height;
-
-	/* put two thirds down */
-	x = ((screen_w - orig_w) / 2) + geometry.x;
-	y = geometry.y + (screen_h / 2) + (screen_h / 2 - orig_h) / 2;
-
-	gtk_window_move (GTK_WINDOW (widget), x, y);
-}
-
-/**
- * gpm_popup_window_show:
- **/
-static void
-gpm_popup_window_show (GtkWidget *widget)
-{
-	GpmPopupWindow *popup;
-
-	/* put two thirds down */
-	gpm_popup_window_move_to_screen_base (widget);
-
-	if (GTK_WIDGET_CLASS (gpm_popup_window_parent_class)->show)
-		GTK_WIDGET_CLASS (gpm_popup_window_parent_class)->show (widget);
-
-	popup = GPM_POPUP_WINDOW (widget);
-	gpm_popup_window_remove_hide_timeout (popup);
-	gpm_popup_window_add_hide_timeout (popup);
-}
-
-/**
- * gpm_popup_window_hide:
- **/
-static void
-gpm_popup_window_hide (GtkWidget *widget)
-{
-	GpmPopupWindow *popup;
-
-	if (GTK_WIDGET_CLASS (gpm_popup_window_parent_class)->hide)
-		GTK_WIDGET_CLASS (gpm_popup_window_parent_class)->hide (widget);
-
-	popup = GPM_POPUP_WINDOW (widget);
-	gpm_popup_window_remove_hide_timeout (popup);
-}
-
-/**
- * gpm_popup_window_realize:
- **/
-static void
-gpm_popup_window_realize (GtkWidget *widget)
-{
-	GtkAllocation allocation;
-	GdkColormap *colormap;
-	GdkBitmap *mask;
-	cairo_t *cr;
-
-	colormap = gdk_screen_get_rgba_colormap (gtk_widget_get_screen (widget));
-
-	if (colormap != NULL)
-		gtk_widget_set_colormap (widget, colormap);
-
-	if (GTK_WIDGET_CLASS (gpm_popup_window_parent_class)->realize)
-		GTK_WIDGET_CLASS (gpm_popup_window_parent_class)->realize (widget);
-
-	gtk_widget_get_allocation (widget, &allocation);
-	mask = gdk_pixmap_new (gtk_widget_get_window (widget),
-			       allocation.width,
-			       allocation.height, 1);
-	cr = gdk_cairo_create (mask);
-
-	cairo_set_source_rgba (cr, 1.0f, 1.0f, 1.0f, 0.0f);
-	cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);
-	cairo_paint (cr);
-
-	/* make the whole window ignore events */
-	gdk_window_input_shape_combine_mask (gtk_widget_get_window (widget), mask, 0, 0);
-	g_object_unref (mask);
-	cairo_destroy (cr);
-}
-
-/**
- * gpm_popup_window_finalize:
- **/
-static void
-gpm_popup_window_finalize (GObject *object)
-{
-	GpmPopupWindow *popup;
-	g_return_if_fail (object != NULL);
-	g_return_if_fail (GPM_IS_POPUP_WINDOW (object));
-
-	popup = GPM_POPUP_WINDOW (object);
-	popup->priv = GPM_POPUP_WINDOW_GET_PRIVATE (popup);
-
-	g_free (popup->priv->icon_name);
-	if (popup->priv->hide_timeout_id != 0)
-		g_source_remove (popup->priv->hide_timeout_id);
-	if (popup->priv->fade_timeout_id != 0)
-		g_source_remove (popup->priv->fade_timeout_id);
-
-	G_OBJECT_CLASS (gpm_popup_window_parent_class)->finalize (object);
-}
-
-/**
- * gpm_popup_window_class_init:
- **/
-static void
-gpm_popup_window_class_init (GpmPopupWindowClass *klass)
-{
-	GObjectClass *object_class = G_OBJECT_CLASS (klass);
-	GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (klass);
-
-	object_class->finalize = gpm_popup_window_finalize;
-
-	widget_class->show = gpm_popup_window_show;
-	widget_class->hide = gpm_popup_window_hide;
-	widget_class->realize = gpm_popup_window_realize;
-
-	g_type_class_add_private (klass, sizeof (GpmPopupWindowPrivate));
-}
-
-/**
- * gpm_popup_window_setup:
- **/
-static void
-gpm_popup_window_setup (GpmPopupWindow *popup)
-{
-	gdouble scalew, scaleh, scale;
-	gint size;
-	GdkScreen *screen;
-	GtkBuilder *builder;
-	gchar **objects;
-
-	/* remove non-composited frame */
-	if (popup->priv->frame != NULL) {
-		gtk_container_remove (GTK_CONTAINER (popup), popup->priv->frame);
-		popup->priv->frame = NULL;
-		popup->priv->image = NULL;
-		popup->priv->progress = NULL;
-	}
-
-	if (popup->priv->is_composited) {
-
-		gtk_window_set_decorated (GTK_WINDOW (popup), FALSE);
-		gtk_widget_set_app_paintable (GTK_WIDGET (popup), TRUE);
-
-		/* assume 130xw30 on a 640x480 display and scale from there */
-		screen = gtk_widget_get_screen (GTK_WIDGET (popup));
-		scalew = gdk_screen_get_width (screen) / 640.0;
-		scaleh = gdk_screen_get_height (screen) / 480.0;
-		scale = MIN (scalew, scaleh);
-		size = 130 * MAX (1, scale);
-
-		gtk_widget_set_size_request (GTK_WIDGET (popup), size, size);
-		gtk_window_set_default_size (GTK_WINDOW (popup), size, size);
-
-	} else {
-		builder = gtk_builder_new ();
-		objects = g_strsplit ("frame_popup", ",", -1);
-		gtk_builder_add_objects_from_file (builder, GPM_DATA "/gpm-feedback-widget.ui", objects, NULL);
-		g_strfreev (objects);
-
-		/* setup non-composited window as a fallback */
-		popup->priv->image = GTK_IMAGE (gtk_builder_get_object (builder, "image_popup"));
-		popup->priv->progress = GTK_WIDGET (gtk_builder_get_object (builder, "progressbar_popup"));
-		popup->priv->frame = GTK_WIDGET (gtk_builder_get_object (builder, "frame_popup"));
-		if (popup->priv->frame != NULL) {
-			gtk_container_add (GTK_CONTAINER (popup), popup->priv->frame);
-			gtk_widget_show_all (popup->priv->frame);
-		}
-
-		/* if we're going from composited to non-composited, set this now */
-		if (popup->priv->icon_name != NULL)
-			gtk_image_set_from_icon_name (popup->priv->image, popup->priv->icon_name, GTK_ICON_SIZE_DIALOG);
-
-		gtk_widget_set_app_paintable (GTK_WIDGET (popup), FALSE);
-		gtk_widget_set_size_request (GTK_WIDGET (popup), -1, -1);
-		gtk_window_set_default_size (GTK_WINDOW (popup), -1, -1);
-
-		/* stay alive until the window takes ownership of the frame (and its children) */
-		g_object_unref (builder);
-		gtk_widget_hide (GTK_WIDGET (popup));
-	}
-}
-
-/**
- * gpm_popup_window_screen_changed_cb:
- **/
-static void
-gpm_popup_window_screen_changed_cb (GdkScreen *screen, GpmPopupWindow *popup)
-{
-	popup->priv->is_composited = gdk_screen_is_composited (screen);
-	egg_debug ("is_composited=%i", popup->priv->is_composited);
-	gpm_popup_window_setup (popup);
-}
-
-/**
- * gpm_popup_window_init:
- **/
-static void
-gpm_popup_window_init (GpmPopupWindow *popup)
-{
-	GdkScreen *screen;
-
-	popup->priv = GPM_POPUP_WINDOW_GET_PRIVATE (popup);
-	popup->priv->fade_out_alpha = 1.0;
-	popup->priv->frame = NULL;
-
-	screen = gtk_widget_get_screen (GTK_WIDGET (popup));
-
-	popup->priv->is_composited = gdk_screen_is_composited (screen);
-	g_signal_connect (screen, "size-changed", G_CALLBACK (gpm_popup_window_screen_changed_cb), popup);
-	g_signal_connect (screen, "monitors-changed", G_CALLBACK (gpm_popup_window_screen_changed_cb), popup);
-	g_signal_connect (screen, "composited-changed", G_CALLBACK (gpm_popup_window_screen_changed_cb), popup);
-
-	/* needed for composite window */
-	g_signal_connect (popup, "expose-event", G_CALLBACK (gpm_popup_window_expose_event_cb), popup);
-
-	/* setup window */
-	gpm_popup_window_setup (popup);
-}
-
-/**
- * gpm_popup_window_new:
- **/
-GtkWidget *
-gpm_popup_window_new (void)
-{
-	GObject *object;
-	object = g_object_new (GPM_TYPE_POPUP_WINDOW,
-			       "type", GTK_WINDOW_POPUP,
-			       "type-hint", GDK_WINDOW_TYPE_HINT_NOTIFICATION,
-			       "skip-taskbar-hint", TRUE,
-			       "skip-pager-hint", TRUE,
-			       "focus-on-map", FALSE,
-			       NULL);
-	return GTK_WIDGET (object);
-}
diff --git a/src/gpm-popup-window.h b/src/gpm-popup-window.h
deleted file mode 100644
index ad3e33e..0000000
--- a/src/gpm-popup-window.h
+++ /dev/null
@@ -1,61 +0,0 @@
-/* -*- Mode: C; tab-width: 8; indent-tabs-mode: t; c-basic-offset: 8 -*-
- *
- * Copyright (C) 2006 William Jon McCann <mccann@jhu.edu>
- * Copyright (C) 2009 Richard Hughes <richard@hughsie.com>
- *
- * Licensed under the GNU General Public License Version 2
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- */
-
-#ifndef GPM_POPUP_WINDOW_H
-#define GPM_POPUP_WINDOW_H
-
-#include <glib-object.h>
-#include <gtk/gtk.h>
-
-G_BEGIN_DECLS
-
-#define GPM_TYPE_POPUP_WINDOW			(gpm_popup_window_get_type ())
-#define GPM_POPUP_WINDOW(obj)			(G_TYPE_CHECK_INSTANCE_CAST ((obj), GPM_TYPE_POPUP_WINDOW, GpmPopupWindow))
-#define GPM_POPUP_WINDOW_CLASS(klass)		(G_TYPE_CHECK_CLASS_CAST ((klass), GPM_TYPE_POPUP_WINDOW, GpmPopupWindowClass))
-#define GPM_IS_POPUP_WINDOW(obj)		(G_TYPE_CHECK_INSTANCE_TYPE ((obj), GPM_TYPE_POPUP_WINDOW))
-#define GPM_IS_POPUP_WINDOW_CLASS(klass)	(G_TYPE_INSTANCE_GET_CLASS ((klass), GPM_TYPE_POPUP_WINDOW))
-
-typedef struct GpmPopupWindow		GpmPopupWindow;
-typedef struct GpmPopupWindowClass	GpmPopupWindowClass;
-typedef struct GpmPopupWindowPrivate	GpmPopupWindowPrivate;
-
-struct GpmPopupWindow
-{
-	GtkWindow		 parent;
-	GpmPopupWindowPrivate	*priv;
-};
-
-struct GpmPopupWindowClass
-{
-	GtkWindowClass		 parent_class;
-};
-
-GType		 gpm_popup_window_get_type		(void);
-GtkWidget	*gpm_popup_window_new			(void);
-void		 gpm_popup_window_set_icon_name		(GpmPopupWindow	*popup,
-							 const gchar	*icon_name);
-void		 gpm_popup_window_set_value		(GpmPopupWindow	*popup,
-							 gfloat		 value);
-
-G_END_DECLS
-
-#endif
diff --git a/src/gsd-media-keys-window.c b/src/gsd-media-keys-window.c
new file mode 100644
index 0000000..cf3c726
--- /dev/null
+++ b/src/gsd-media-keys-window.c
@@ -0,0 +1,1109 @@
+/* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 8 -*-
+ *
+ * Copyright (C) 2006-2007 William Jon McCann <mccann@jhu.edu>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <glib.h>
+#include <glib/gi18n.h>
+#include <gtk/gtk.h>
+
+#include "gsd-media-keys-window.h"
+
+#define DIALOG_TIMEOUT 2000     /* dialog timeout in ms */
+#define DIALOG_FADE_TIMEOUT 1500 /* timeout before fade starts */
+#define FADE_TIMEOUT 10        /* timeout in ms between each frame of the fade */
+
+#define BG_ALPHA 0.75
+#define FG_ALPHA 1.00
+
+#define GSD_MEDIA_KEYS_WINDOW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GSD_TYPE_MEDIA_KEYS_WINDOW, GsdMediaKeysWindowPrivate))
+
+struct GsdMediaKeysWindowPrivate
+{
+        guint                    is_composited : 1;
+        guint                    hide_timeout_id;
+        guint                    fade_timeout_id;
+        double                   fade_out_alpha;
+        GsdMediaKeysWindowAction action;
+
+        guint                    volume_muted : 1;
+        int                      volume_level;
+
+        GtkImage                *image;
+        GtkWidget               *progress;
+};
+
+G_DEFINE_TYPE (GsdMediaKeysWindow, gsd_media_keys_window, GTK_TYPE_WINDOW)
+
+static gboolean
+fade_timeout (GsdMediaKeysWindow *window)
+{
+        if (window->priv->fade_out_alpha <= 0.0) {
+                gtk_widget_hide (GTK_WIDGET (window));
+
+                /* Reset it for the next time */
+                window->priv->fade_out_alpha = 1.0;
+                window->priv->fade_timeout_id = 0;
+
+                return FALSE;
+        } else {
+                GdkRectangle rect;
+                GtkWidget *win = GTK_WIDGET (window);
+                GtkAllocation allocation;
+
+                window->priv->fade_out_alpha -= 0.10;
+
+                rect.x = 0;
+                rect.y = 0;
+                gtk_widget_get_allocation (win, &allocation);
+                rect.width = allocation.width;
+                rect.height = allocation.height;
+
+                gdk_window_invalidate_rect (gtk_widget_get_window (win), &rect, FALSE);
+        }
+
+        return TRUE;
+}
+
+static gboolean
+hide_timeout (GsdMediaKeysWindow *window)
+{
+        if (window->priv->is_composited) {
+                window->priv->hide_timeout_id = 0;
+                window->priv->fade_timeout_id = g_timeout_add (FADE_TIMEOUT,
+                                                               (GSourceFunc) fade_timeout,
+                                                               window);
+        } else {
+                gtk_widget_hide (GTK_WIDGET (window));
+        }
+
+        return FALSE;
+}
+
+static void
+remove_hide_timeout (GsdMediaKeysWindow *window)
+{
+        if (window->priv->hide_timeout_id != 0) {
+                g_source_remove (window->priv->hide_timeout_id);
+                window->priv->hide_timeout_id = 0;
+        }
+
+        if (window->priv->fade_timeout_id != 0) {
+                g_source_remove (window->priv->fade_timeout_id);
+                window->priv->fade_timeout_id = 0;
+                window->priv->fade_out_alpha = 1.0;
+        }
+}
+
+static void
+add_hide_timeout (GsdMediaKeysWindow *window)
+{
+        int timeout;
+
+        if (window->priv->is_composited) {
+                timeout = DIALOG_FADE_TIMEOUT;
+        } else {
+                timeout = DIALOG_TIMEOUT;
+        }
+        window->priv->hide_timeout_id = g_timeout_add (timeout,
+                                                       (GSourceFunc) hide_timeout,
+                                                       window);
+}
+
+static void
+update_window (GsdMediaKeysWindow *window)
+{
+        remove_hide_timeout (window);
+        add_hide_timeout (window);
+
+        if (window->priv->is_composited) {
+                gtk_widget_queue_draw (GTK_WIDGET (window));
+        }
+}
+
+static void
+volume_controls_set_visible (GsdMediaKeysWindow *window,
+                             gboolean            visible)
+{
+        if (window->priv->progress == NULL)
+                return;
+
+        if (visible) {
+                gtk_widget_show (window->priv->progress);
+        } else {
+                gtk_widget_hide (window->priv->progress);
+        }
+}
+
+static void
+window_set_icon_name (GsdMediaKeysWindow *window,
+                      const char         *name)
+{
+        if (window->priv->image == NULL)
+                return;
+
+        gtk_image_set_from_icon_name (window->priv->image,
+                                      name, GTK_ICON_SIZE_DIALOG);
+}
+
+static void
+action_changed (GsdMediaKeysWindow *window)
+{
+        if (! window->priv->is_composited) {
+                switch (window->priv->action) {
+                case GSD_MEDIA_KEYS_WINDOW_ACTION_VOLUME:
+                        volume_controls_set_visible (window, TRUE);
+
+                        if (window->priv->volume_muted) {
+                                window_set_icon_name (window, "audio-volume-muted");
+                        } else {
+                                window_set_icon_name (window, "audio-volume-high");
+                        }
+
+                        break;
+                case GSD_MEDIA_KEYS_WINDOW_ACTION_EJECT:
+                        volume_controls_set_visible (window, FALSE);
+                        window_set_icon_name (window, "media-eject");
+                        break;
+                case GSD_MEDIA_KEYS_WINDOW_ACTION_BRIGHTNESS:
+                        volume_controls_set_visible (window, TRUE);
+                        window_set_icon_name (window, "gpm-brightness-lcd");
+                        break;
+                default:
+                        break;
+                }
+        }
+
+        update_window (window);
+}
+
+static void
+volume_level_changed (GsdMediaKeysWindow *window)
+{
+        update_window (window);
+
+        if (!window->priv->is_composited && window->priv->progress != NULL) {
+                double fraction;
+
+                fraction = (double) window->priv->volume_level / 100.0;
+
+                gtk_progress_bar_set_fraction (GTK_PROGRESS_BAR (window->priv->progress),
+                                               fraction);
+        }
+}
+
+static void
+volume_muted_changed (GsdMediaKeysWindow *window)
+{
+        update_window (window);
+
+        if (! window->priv->is_composited) {
+                if (window->priv->volume_muted) {
+                        window_set_icon_name (window, "audio-volume-muted");
+                } else {
+                        window_set_icon_name (window, "audio-volume-high");
+                }
+        }
+}
+
+void
+gsd_media_keys_window_set_action (GsdMediaKeysWindow      *window,
+                                  GsdMediaKeysWindowAction action)
+{
+        g_return_if_fail (GSD_IS_MEDIA_KEYS_WINDOW (window));
+
+        if (window->priv->action != action) {
+                window->priv->action = action;
+                action_changed (window);
+        }
+}
+
+void
+gsd_media_keys_window_set_volume_muted (GsdMediaKeysWindow *window,
+                                        gboolean            muted)
+{
+        g_return_if_fail (GSD_IS_MEDIA_KEYS_WINDOW (window));
+
+        if (window->priv->volume_muted != muted) {
+                window->priv->volume_muted = muted;
+                volume_muted_changed (window);
+        }
+}
+
+void
+gsd_media_keys_window_set_volume_level (GsdMediaKeysWindow *window,
+                                        int                 level)
+{
+        g_return_if_fail (GSD_IS_MEDIA_KEYS_WINDOW (window));
+
+        if (window->priv->volume_level != level) {
+                window->priv->volume_level = level;
+                volume_level_changed (window);
+        }
+}
+
+static void
+rounded_rectangle (cairo_t* cr,
+                   gdouble  aspect,
+                   gdouble  x,
+                   gdouble  y,
+                   gdouble  corner_radius,
+                   gdouble  width,
+                   gdouble  height)
+{
+        gdouble radius = corner_radius / aspect;
+
+        cairo_move_to (cr, x + radius, y);
+
+        cairo_line_to (cr,
+                       x + width - radius,
+                       y);
+        cairo_arc (cr,
+                   x + width - radius,
+                   y + radius,
+                   radius,
+                   -90.0f * G_PI / 180.0f,
+                   0.0f * G_PI / 180.0f);
+        cairo_line_to (cr,
+                       x + width,
+                       y + height - radius);
+        cairo_arc (cr,
+                   x + width - radius,
+                   y + height - radius,
+                   radius,
+                   0.0f * G_PI / 180.0f,
+                   90.0f * G_PI / 180.0f);
+        cairo_line_to (cr,
+                       x + radius,
+                       y + height);
+        cairo_arc (cr,
+                   x + radius,
+                   y + height - radius,
+                   radius,
+                   90.0f * G_PI / 180.0f,
+                   180.0f * G_PI / 180.0f);
+        cairo_line_to (cr,
+                       x,
+                       y + radius);
+        cairo_arc (cr,
+                   x + radius,
+                   y + radius,
+                   radius,
+                   180.0f * G_PI / 180.0f,
+                   270.0f * G_PI / 180.0f);
+        cairo_close_path (cr);
+}
+
+static GdkPixbuf *
+load_pixbuf (GsdMediaKeysWindow *window,
+             const char         *name,
+             int                 icon_size)
+{
+        GtkIconTheme *theme;
+        GdkPixbuf    *pixbuf;
+
+        if (window != NULL && gtk_widget_has_screen (GTK_WIDGET (window))) {
+                theme = gtk_icon_theme_get_for_screen (gtk_widget_get_screen (GTK_WIDGET (window)));
+        } else {
+                theme = gtk_icon_theme_get_default ();
+        }
+
+        pixbuf = gtk_icon_theme_load_icon (theme,
+                                           name,
+                                           icon_size,
+                                           GTK_ICON_LOOKUP_FORCE_SVG,
+                                           NULL);
+
+        /* make sure the pixbuf is close to the requested size
+         * this is necessary because GTK_ICON_LOOKUP_FORCE_SVG
+         * seems to be broken */
+        if (pixbuf != NULL) {
+                int width;
+
+                width = gdk_pixbuf_get_width (pixbuf);
+                if (width < (float)icon_size * 0.75) {
+                        g_object_unref (pixbuf);
+                        pixbuf = NULL;
+                }
+        }
+
+        return pixbuf;
+}
+
+static gboolean
+render_eject (GsdMediaKeysWindow *window,
+              cairo_t            *cr,
+              double              _x0,
+              double              _y0,
+              double              width,
+              double              height)
+{
+        GdkPixbuf  *pixbuf;
+        int         icon_size;
+        const char *icon_name;
+
+        icon_name = "media-eject";
+
+        icon_size = (int)width;
+
+        pixbuf = load_pixbuf (window, icon_name, icon_size);
+
+        if (pixbuf == NULL) {
+                return FALSE;
+        }
+
+        gdk_cairo_set_source_pixbuf (cr, pixbuf, _x0, _y0);
+        cairo_paint_with_alpha (cr, FG_ALPHA);
+
+        g_object_unref (pixbuf);
+
+        return TRUE;
+}
+
+static void
+draw_eject (cairo_t *cr,
+            double   _x0,
+            double   _y0,
+            double   width,
+            double   height)
+{
+        int box_height;
+        int tri_height;
+        int separation;
+
+        box_height = height * 0.2;
+        separation = box_height / 3;
+        tri_height = height - box_height - separation;
+
+        cairo_rectangle (cr, _x0, _y0 + height - box_height, width, box_height);
+
+        cairo_move_to (cr, _x0, _y0 + tri_height);
+        cairo_rel_line_to (cr, width, 0);
+        cairo_rel_line_to (cr, -width / 2, -tri_height);
+        cairo_rel_line_to (cr, -width / 2, tri_height);
+        cairo_close_path (cr);
+        cairo_set_source_rgba (cr, 1.0, 1.0, 1.0, FG_ALPHA);
+        cairo_fill_preserve (cr);
+
+        cairo_set_source_rgba (cr, 0.6, 0.6, 0.6, FG_ALPHA / 2);
+        cairo_set_line_width (cr, 2);
+        cairo_stroke (cr);
+}
+
+static void
+draw_action_eject (GsdMediaKeysWindow *window,
+                   cairo_t            *cr)
+{
+        int      window_width;
+        int      window_height;
+        double   width;
+        double   height;
+        double   _x0;
+        double   _y0;
+        gboolean res;
+
+        gtk_window_get_size (GTK_WINDOW (window), &window_width, &window_height);
+
+        width = window_width * 0.65;
+        height = window_height * 0.65;
+        _x0 = (window_width - width) / 2;
+        _y0 = (window_height - height) / 2;
+
+#if 0
+        g_message ("eject box: w=%f h=%f _x0=%f _y0=%f",
+                   width,
+                   height,
+                   _x0,
+                   _y0);
+#endif
+
+        res = render_eject (window,
+                            cr,
+                            _x0, _y0,
+                            width, height);
+        if (! res) {
+                /* draw eject symbol */
+                draw_eject (cr, _x0, _y0, width, height);
+        }
+}
+
+static void
+draw_waves (cairo_t *cr,
+            double   cx,
+            double   cy,
+            double   max_radius,
+            int      volume_level)
+{
+        const int n_waves = 3;
+        int last_wave;
+        int i;
+
+        last_wave = n_waves * volume_level / 100;
+
+        for (i = 0; i < n_waves; i++) {
+                double angle1;
+                double angle2;
+                double radius;
+                double alpha;
+
+                angle1 = -M_PI / 4;
+                angle2 = M_PI / 4;
+
+                if (i < last_wave)
+                        alpha = 1.0;
+                else if (i > last_wave)
+                        alpha = 0.1;
+                else alpha = 0.1 + 0.9 * (n_waves * volume_level % 100) / 100.0;
+
+                radius = (i + 1) * (max_radius / n_waves);
+                cairo_arc (cr, cx, cy, radius, angle1, angle2);
+                cairo_set_source_rgba (cr, 0.6, 0.6, 0.6, alpha / 2);
+                cairo_set_line_width (cr, 14);
+                cairo_set_line_cap  (cr, CAIRO_LINE_CAP_ROUND);
+                cairo_stroke_preserve (cr);
+
+                cairo_set_source_rgba (cr, 1.0, 1.0, 1.0, alpha);
+                cairo_set_line_width (cr, 10);
+                cairo_set_line_cap  (cr, CAIRO_LINE_CAP_ROUND);
+                cairo_stroke (cr);
+        }
+}
+
+static void
+draw_cross (cairo_t *cr,
+            double   cx,
+            double   cy,
+            double   size)
+{
+        cairo_move_to (cr, cx, cy - size/2.0);
+        cairo_rel_line_to (cr, size, size);
+
+        cairo_move_to (cr, cx, cy + size/2.0);
+        cairo_rel_line_to (cr, size, -size);
+
+        cairo_set_source_rgba (cr, 0.6, 0.6, 0.6, FG_ALPHA / 2);
+        cairo_set_line_width (cr, 14);
+        cairo_set_line_cap (cr, CAIRO_LINE_CAP_ROUND);
+        cairo_stroke_preserve (cr);
+
+        cairo_set_source_rgba (cr, 1.0, 1.0, 1.0, FG_ALPHA);
+        cairo_set_line_width (cr, 10);
+        cairo_set_line_cap (cr, CAIRO_LINE_CAP_ROUND);
+        cairo_stroke (cr);
+}
+
+static void
+draw_speaker (cairo_t *cr,
+              double   cx,
+              double   cy,
+              double   width,
+              double   height)
+{
+        double box_width;
+        double box_height;
+        double _x0;
+        double _y0;
+
+        box_width = width / 3;
+        box_height = height / 3;
+
+        _x0 = cx - (width / 2) + box_width;
+        _y0 = cy - box_height / 2;
+
+        cairo_move_to (cr, _x0, _y0);
+        cairo_rel_line_to (cr, - box_width, 0);
+        cairo_rel_line_to (cr, 0, box_height);
+        cairo_rel_line_to (cr, box_width, 0);
+
+        cairo_line_to (cr, cx + box_width, cy + height / 2);
+        cairo_rel_line_to (cr, 0, -height);
+        cairo_line_to (cr, _x0, _y0);
+        cairo_close_path (cr);
+
+        cairo_set_source_rgba (cr, 1.0, 1.0, 1.0, FG_ALPHA);
+        cairo_fill_preserve (cr);
+
+        cairo_set_source_rgba (cr, 0.6, 0.6, 0.6, FG_ALPHA / 2);
+        cairo_set_line_width (cr, 2);
+        cairo_stroke (cr);
+}
+
+static gboolean
+render_speaker (GsdMediaKeysWindow *window,
+                cairo_t            *cr,
+                double              _x0,
+                double              _y0,
+                double              width,
+                double              height)
+{
+        GdkPixbuf         *pixbuf;
+        int                icon_size;
+        int                n;
+        static const char *icon_names[] = {
+                "audio-volume-muted",
+                "audio-volume-low",
+                "audio-volume-medium",
+                "audio-volume-high",
+                NULL
+        };
+
+        if (window->priv->volume_muted) {
+                n = 0;
+        } else {
+                /* select image */
+                n = 3 * window->priv->volume_level / 100 + 1;
+                if (n < 1) {
+                        n = 1;
+                } else if (n > 3) {
+                        n = 3;
+                }
+        }
+
+        icon_size = (int)width;
+
+        pixbuf = load_pixbuf (window, icon_names[n], icon_size);
+
+        if (pixbuf == NULL) {
+                return FALSE;
+        }
+
+        gdk_cairo_set_source_pixbuf (cr, pixbuf, _x0, _y0);
+        cairo_paint_with_alpha (cr, FG_ALPHA);
+
+        g_object_unref (pixbuf);
+
+        return TRUE;
+}
+
+static void
+color_reverse (const GdkColor *a,
+               GdkColor       *b)
+{
+        gdouble red;
+        gdouble green;
+        gdouble blue;
+        gdouble h;
+        gdouble s;
+        gdouble v;
+
+        red = (gdouble) a->red / 65535.0;
+        green = (gdouble) a->green / 65535.0;
+        blue = (gdouble) a->blue / 65535.0;
+
+        gtk_rgb_to_hsv (red, green, blue, &h, &s, &v);
+
+        v = 0.5 + (0.5 - v);
+        if (v > 1.0)
+                v = 1.0;
+        else if (v < 0.0)
+                v = 0.0;
+
+        gtk_hsv_to_rgb (h, s, v, &red, &green, &blue);
+
+        b->red = red * 65535.0;
+        b->green = green * 65535.0;
+        b->blue = blue * 65535.0;
+}
+
+static void
+draw_volume_boxes (GsdMediaKeysWindow *window,
+                   cairo_t            *cr,
+                   double              percentage,
+                   double              _x0,
+                   double              _y0,
+                   double              width,
+                   double              height)
+{
+        gdouble   x1;
+        GdkColor  color;
+        double    r, g, b;
+        GtkStyle *style;
+
+        _x0 += 0.5;
+        _y0 += 0.5;
+        height = round (height) - 1;
+        width = round (width) - 1;
+        x1 = round ((width - 1) * percentage);
+        style = gtk_widget_get_style (GTK_WIDGET (window));
+
+        /* bar background */
+        color_reverse (&style->dark[GTK_STATE_NORMAL], &color);
+        r = (float)color.red / 65535.0;
+        g = (float)color.green / 65535.0;
+        b = (float)color.blue / 65535.0;
+        rounded_rectangle (cr, 1.0, _x0, _y0, height / 6, width, height);
+        cairo_set_source_rgba (cr, r, g, b, FG_ALPHA / 2);
+        cairo_fill_preserve (cr);
+
+        /* bar border */
+        color_reverse (&style->light[GTK_STATE_NORMAL], &color);
+        r = (float)color.red / 65535.0;
+        g = (float)color.green / 65535.0;
+        b = (float)color.blue / 65535.0;
+        cairo_set_source_rgba (cr, r, g, b, FG_ALPHA / 2);
+        cairo_set_line_width (cr, 1);
+        cairo_stroke (cr);
+
+        /* bar progress */
+        if (percentage < 0.01)
+                return;
+        color = style->bg[GTK_STATE_NORMAL];
+        r = (float)color.red / 65535.0;
+        g = (float)color.green / 65535.0;
+        b = (float)color.blue / 65535.0;
+        rounded_rectangle (cr, 1.0, _x0 + 0.5, _y0 + 0.5, height / 6 - 0.5, x1, height - 1);
+        cairo_set_source_rgba (cr, r, g, b, FG_ALPHA);
+        cairo_fill (cr);
+}
+
+static void
+draw_action_volume (GsdMediaKeysWindow *window,
+                    cairo_t            *cr)
+{
+        int window_width;
+        int window_height;
+        double icon_box_width;
+        double icon_box_height;
+        double icon_box_x0;
+        double icon_box_y0;
+        double volume_box_x0;
+        double volume_box_y0;
+        double volume_box_width;
+        double volume_box_height;
+        gboolean res;
+
+        gtk_window_get_size (GTK_WINDOW (window), &window_width, &window_height);
+
+        icon_box_width = round (window_width * 0.65);
+        icon_box_height = round (window_height * 0.65);
+        volume_box_width = icon_box_width;
+        volume_box_height = round (window_height * 0.05);
+
+        icon_box_x0 = (window_width - icon_box_width) / 2;
+        icon_box_y0 = (window_height - icon_box_height - volume_box_height) / 2;
+        volume_box_x0 = round (icon_box_x0);
+        volume_box_y0 = round (icon_box_height + icon_box_y0);
+
+#if 0
+        g_message ("icon box: w=%f h=%f _x0=%f _y0=%f",
+                   icon_box_width,
+                   icon_box_height,
+                   icon_box_x0,
+                   icon_box_y0);
+        g_message ("volume box: w=%f h=%f _x0=%f _y0=%f",
+                   volume_box_width,
+                   volume_box_height,
+                   volume_box_x0,
+                   volume_box_y0);
+#endif
+
+        res = render_speaker (window,
+                              cr,
+                              icon_box_x0, icon_box_y0,
+                              icon_box_width, icon_box_height);
+        if (! res) {
+                double speaker_width;
+                double speaker_height;
+                double speaker_cx;
+                double speaker_cy;
+
+                speaker_width = icon_box_width * 0.5;
+                speaker_height = icon_box_height * 0.75;
+                speaker_cx = icon_box_x0 + speaker_width / 2;
+                speaker_cy = icon_box_y0 + speaker_height / 2;
+
+#if 0
+                g_message ("speaker box: w=%f h=%f cx=%f cy=%f",
+                           speaker_width,
+                           speaker_height,
+                           speaker_cx,
+                           speaker_cy);
+#endif
+
+                /* draw speaker symbol */
+                draw_speaker (cr, speaker_cx, speaker_cy, speaker_width, speaker_height);
+
+                if (! window->priv->volume_muted) {
+                        /* draw sound waves */
+                        double wave_x0;
+                        double wave_y0;
+                        double wave_radius;
+
+                        wave_x0 = window_width / 2;
+                        wave_y0 = speaker_cy;
+                        wave_radius = icon_box_width / 2;
+
+                        draw_waves (cr, wave_x0, wave_y0, wave_radius, window->priv->volume_level);
+                } else {
+                        /* draw 'mute' cross */
+                        double cross_x0;
+                        double cross_y0;
+                        double cross_size;
+
+                        cross_size = speaker_width * 3 / 4;
+                        cross_x0 = icon_box_x0 + icon_box_width - cross_size;
+                        cross_y0 = speaker_cy;
+
+                        draw_cross (cr, cross_x0, cross_y0, cross_size);
+                }
+        }
+
+        /* draw volume meter */
+        draw_volume_boxes (window,
+                           cr,
+                           (double)window->priv->volume_level / 100.0,
+                           volume_box_x0,
+                           volume_box_y0,
+                           volume_box_width,
+                           volume_box_height);
+}
+
+static gboolean
+render_brightness (GsdMediaKeysWindow *window,
+                   cairo_t            *cr,
+                   double              _x0,
+                   double              _y0,
+                   double              width,
+                   double              height)
+{
+        GdkPixbuf         *pixbuf;
+        int                icon_size;
+
+        icon_size = (int)width;
+
+        pixbuf = load_pixbuf (window, "gpm-brightness-lcd", icon_size);
+
+        if (pixbuf == NULL) {
+                return FALSE;
+        }
+
+        gdk_cairo_set_source_pixbuf (cr, pixbuf, _x0, _y0);
+        cairo_paint_with_alpha (cr, FG_ALPHA);
+
+        g_object_unref (pixbuf);
+
+        return TRUE;
+}
+
+static void
+draw_action_brightness (GsdMediaKeysWindow *window,
+                        cairo_t            *cr)
+{
+        int window_width;
+        int window_height;
+        double icon_box_width;
+        double icon_box_height;
+        double icon_box_x0;
+        double icon_box_y0;
+        double bright_box_x0;
+        double bright_box_y0;
+        double bright_box_width;
+        double bright_box_height;
+        gboolean res;
+
+        gtk_window_get_size (GTK_WINDOW (window), &window_width, &window_height);
+
+        icon_box_width = round (window_width * 0.65);
+        icon_box_height = round (window_height * 0.65);
+        bright_box_width = round (icon_box_width);
+        bright_box_height = round (window_height * 0.05);
+
+        icon_box_x0 = (window_width - icon_box_width) / 2;
+        icon_box_y0 = (window_height - icon_box_height - bright_box_height) / 2;
+        bright_box_x0 = round (icon_box_x0);
+        bright_box_y0 = round (icon_box_height + icon_box_y0);
+
+#if 0
+        g_message ("icon box: w=%f h=%f _x0=%f _y0=%f",
+                   icon_box_width,
+                   icon_box_height,
+                   icon_box_x0,
+                   icon_box_y0);
+        g_message ("brightness box: w=%f h=%f _x0=%f _y0=%f",
+                   bright_box_width,
+                   bright_box_height,
+                   bright_box_x0,
+                   bright_box_y0);
+#endif
+
+        res = render_brightness (window,
+                                 cr,
+                                 icon_box_x0, icon_box_y0,
+                                 icon_box_width, icon_box_height);
+
+        /* draw volume meter */
+        draw_volume_boxes (window,
+                           cr,
+                           (double)window->priv->volume_level / 100.0,
+                           bright_box_x0,
+                           bright_box_y0,
+                           bright_box_width,
+                           bright_box_height);
+}
+
+static void
+draw_action (GsdMediaKeysWindow *window,
+             cairo_t            *cr)
+{
+        switch (window->priv->action) {
+        case GSD_MEDIA_KEYS_WINDOW_ACTION_VOLUME:
+                draw_action_volume (window, cr);
+                break;
+        case GSD_MEDIA_KEYS_WINDOW_ACTION_EJECT:
+                draw_action_eject (window, cr);
+                break;
+        case GSD_MEDIA_KEYS_WINDOW_ACTION_BRIGHTNESS:
+                draw_action_brightness (window, cr);
+                break;
+        default:
+                break;
+        }
+}
+
+static gboolean
+on_expose_event (GtkWidget          *widget,
+                 GdkEventExpose     *event,
+                 GsdMediaKeysWindow *window)
+{
+        cairo_t         *context;
+        cairo_t         *cr;
+        cairo_surface_t *surface;
+        int              width;
+        int              height;
+        GtkStyle        *style;
+        GdkColor         color;
+        double           r, g, b;
+
+        context = gdk_cairo_create (gtk_widget_get_window (widget));
+
+        style = gtk_widget_get_style (widget);
+        cairo_set_operator (context, CAIRO_OPERATOR_SOURCE);
+        gtk_window_get_size (GTK_WINDOW (widget), &width, &height);
+
+        surface = cairo_surface_create_similar (cairo_get_target (context),
+                                                CAIRO_CONTENT_COLOR_ALPHA,
+                                                width,
+                                                height);
+
+        if (cairo_surface_status (surface) != CAIRO_STATUS_SUCCESS) {
+                goto done;
+        }
+
+        cr = cairo_create (surface);
+        if (cairo_status (cr) != CAIRO_STATUS_SUCCESS) {
+                goto done;
+        }
+        cairo_set_source_rgba (cr, 1.0, 1.0, 1.0, 0.0);
+        cairo_set_operator (cr, CAIRO_OPERATOR_OVER);
+        cairo_paint (cr);
+
+        /* draw a box */
+        rounded_rectangle (cr, 1.0, 0.5, 0.5, height / 10, width-1, height-1);
+        color_reverse (&style->bg[GTK_STATE_NORMAL], &color);
+        r = (float)color.red / 65535.0;
+        g = (float)color.green / 65535.0;
+        b = (float)color.blue / 65535.0;
+        cairo_set_source_rgba (cr, r, g, b, BG_ALPHA);
+        cairo_fill_preserve (cr);
+
+        color_reverse (&style->text_aa[GTK_STATE_NORMAL], &color);
+        r = (float)color.red / 65535.0;
+        g = (float)color.green / 65535.0;
+        b = (float)color.blue / 65535.0;
+        cairo_set_source_rgba (cr, r, g, b, BG_ALPHA / 2);
+        cairo_set_line_width (cr, 1);
+        cairo_stroke (cr);
+
+        /* draw action */
+        draw_action (window, cr);
+
+        cairo_destroy (cr);
+
+        /* Make sure we have a transparent background */
+        cairo_rectangle (context, 0, 0, width, height);
+        cairo_set_source_rgba (context, 0.0, 0.0, 0.0, 0.0);
+        cairo_fill (context);
+
+        cairo_set_source_surface (context, surface, 0, 0);
+        cairo_paint_with_alpha (context, window->priv->fade_out_alpha);
+
+ done:
+        if (surface != NULL) {
+                cairo_surface_destroy (surface);
+        }
+        cairo_destroy (context);
+
+        return FALSE;
+}
+
+static void
+gsd_media_keys_window_real_show (GtkWidget *widget)
+{
+        GsdMediaKeysWindow *window;
+
+        if (GTK_WIDGET_CLASS (gsd_media_keys_window_parent_class)->show) {
+                GTK_WIDGET_CLASS (gsd_media_keys_window_parent_class)->show (widget);
+        }
+
+        window = GSD_MEDIA_KEYS_WINDOW (widget);
+        remove_hide_timeout (window);
+        add_hide_timeout (window);
+}
+
+static void
+gsd_media_keys_window_real_hide (GtkWidget *widget)
+{
+        GsdMediaKeysWindow *window;
+
+        if (GTK_WIDGET_CLASS (gsd_media_keys_window_parent_class)->hide) {
+                GTK_WIDGET_CLASS (gsd_media_keys_window_parent_class)->hide (widget);
+        }
+
+        window = GSD_MEDIA_KEYS_WINDOW (widget);
+        remove_hide_timeout (window);
+}
+
+static void
+gsd_media_keys_window_real_realize (GtkWidget *widget)
+{
+        GdkColormap *colormap;
+        GtkAllocation allocation;
+        GdkBitmap *mask;
+        cairo_t *cr;
+
+        colormap = gdk_screen_get_rgba_colormap (gtk_widget_get_screen (widget));
+
+        if (colormap != NULL) {
+                gtk_widget_set_colormap (widget, colormap);
+        }
+
+        if (GTK_WIDGET_CLASS (gsd_media_keys_window_parent_class)->realize) {
+                GTK_WIDGET_CLASS (gsd_media_keys_window_parent_class)->realize (widget);
+        }
+
+        gtk_widget_get_allocation (widget, &allocation);
+        mask = gdk_pixmap_new (gtk_widget_get_window (widget),
+                               allocation.width,
+                               allocation.height,
+                               1);
+        cr = gdk_cairo_create (mask);
+
+        cairo_set_source_rgba (cr, 1., 1., 1., 0.);
+        cairo_set_operator (cr, CAIRO_OPERATOR_SOURCE);
+        cairo_paint (cr);
+
+        /* make the whole window ignore events */
+        gdk_window_input_shape_combine_mask (gtk_widget_get_window (widget), mask, 0, 0);
+        g_object_unref (mask);
+        cairo_destroy (cr);
+}
+
+static void
+gsd_media_keys_window_class_init (GsdMediaKeysWindowClass *klass)
+{
+        GtkWidgetClass *widget_class = GTK_WIDGET_CLASS (klass);
+
+        widget_class->show = gsd_media_keys_window_real_show;
+        widget_class->hide = gsd_media_keys_window_real_hide;
+        widget_class->realize = gsd_media_keys_window_real_realize;
+
+        g_type_class_add_private (klass, sizeof (GsdMediaKeysWindowPrivate));
+}
+
+gboolean
+gsd_media_keys_window_is_valid (GsdMediaKeysWindow *window)
+{
+        GdkScreen *screen = gtk_widget_get_screen (GTK_WIDGET (window));
+        return gdk_screen_is_composited (screen) == window->priv->is_composited;
+}
+
+static void
+gsd_media_keys_window_init (GsdMediaKeysWindow *window)
+{
+        GdkScreen *screen;
+
+        window->priv = GSD_MEDIA_KEYS_WINDOW_GET_PRIVATE (window);
+
+        screen = gtk_widget_get_screen (GTK_WIDGET (window));
+
+        window->priv->is_composited = gdk_screen_is_composited (screen);
+
+        if (window->priv->is_composited) {
+                gdouble scalew, scaleh, scale;
+                gint size;
+
+                gtk_window_set_decorated (GTK_WINDOW (window), FALSE);
+                gtk_widget_set_app_paintable (GTK_WIDGET (window), TRUE);
+
+                /* assume 130x130 on a 640x480 display and scale from there */
+                scalew = gdk_screen_get_width (screen) / 640.0;
+                scaleh = gdk_screen_get_height (screen) / 480.0;
+                scale = MIN (scalew, scaleh);
+                size = 130 * MAX (1, scale);
+
+                gtk_window_set_default_size (GTK_WINDOW (window), size, size);
+                g_signal_connect (window, "expose-event", G_CALLBACK (on_expose_event), window);
+
+                window->priv->fade_out_alpha = 1.0;
+        } else {
+                GtkBuilder *builder;
+                const gchar *objects[] = {"acme_frame", NULL};
+                GtkWidget *frame;
+
+                builder = gtk_builder_new ();
+                gtk_builder_add_objects_from_file (builder,
+                                                   GTKBUILDERDIR "/acme.ui",
+                                                   (char **) objects,
+                                                   NULL);
+
+                window->priv->image = GTK_IMAGE (gtk_builder_get_object (builder, "acme_image"));
+                window->priv->progress = GTK_WIDGET (gtk_builder_get_object (builder, "acme_volume_progressbar"));
+                frame = GTK_WIDGET (gtk_builder_get_object (builder,
+                                                            "acme_frame"));
+
+                if (frame != NULL) {
+                        gtk_container_add (GTK_CONTAINER (window), frame);
+                        gtk_widget_show_all (frame);
+                }
+
+                /* The builder needs to stay alive until the window
+                   takes ownership of the frame (and its children)  */
+                g_object_unref (builder);
+        }
+}
+
+GtkWidget *
+gsd_media_keys_window_new (void)
+{
+        GObject *object;
+
+        object = g_object_new (GSD_TYPE_MEDIA_KEYS_WINDOW,
+                               "type", GTK_WINDOW_POPUP,
+                               "type-hint", GDK_WINDOW_TYPE_HINT_NOTIFICATION,
+                               "skip-taskbar-hint", TRUE,
+                               "skip-pager-hint", TRUE,
+                               "focus-on-map", FALSE,
+                               NULL);
+
+        return GTK_WIDGET (object);
+}
diff --git a/src/gsd-media-keys-window.h b/src/gsd-media-keys-window.h
new file mode 100644
index 0000000..dd4ae90
--- /dev/null
+++ b/src/gsd-media-keys-window.h
@@ -0,0 +1,69 @@
+/* -*- Mode: C; indent-tabs-mode: nil; c-basic-offset: 8; tab-width: 8 -*-
+ *
+ * Copyright (C) 2006 William Jon McCann <mccann@jhu.edu>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public
+ * License along with this program; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef GSD_MEDIA_KEYS_WINDOW_H
+#define GSD_MEDIA_KEYS_WINDOW_H
+
+#include <glib-object.h>
+#include <gtk/gtk.h>
+
+G_BEGIN_DECLS
+
+#define GSD_TYPE_MEDIA_KEYS_WINDOW            (gsd_media_keys_window_get_type ())
+#define GSD_MEDIA_KEYS_WINDOW(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj),  GSD_TYPE_MEDIA_KEYS_WINDOW, GsdMediaKeysWindow))
+#define GSD_MEDIA_KEYS_WINDOW_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),   GSD_TYPE_MEDIA_KEYS_WINDOW, GsdMediaKeysWindowClass))
+#define GSD_IS_MEDIA_KEYS_WINDOW(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj),  GSD_TYPE_MEDIA_KEYS_WINDOW))
+#define GSD_IS_MEDIA_KEYS_WINDOW_CLASS(klass) (G_TYPE_INSTANCE_GET_CLASS ((klass), GSD_TYPE_MEDIA_KEYS_WINDOW))
+
+typedef struct GsdMediaKeysWindow                   GsdMediaKeysWindow;
+typedef struct GsdMediaKeysWindowClass              GsdMediaKeysWindowClass;
+typedef struct GsdMediaKeysWindowPrivate            GsdMediaKeysWindowPrivate;
+
+struct GsdMediaKeysWindow {
+        GtkWindow                   parent;
+
+        GsdMediaKeysWindowPrivate  *priv;
+};
+
+struct GsdMediaKeysWindowClass {
+        GtkWindowClass parent_class;
+};
+
+typedef enum {
+        GSD_MEDIA_KEYS_WINDOW_ACTION_VOLUME,
+        GSD_MEDIA_KEYS_WINDOW_ACTION_EJECT,
+        GSD_MEDIA_KEYS_WINDOW_ACTION_BRIGHTNESS
+} GsdMediaKeysWindowAction;
+
+GType                 gsd_media_keys_window_get_type          (void);
+
+GtkWidget *           gsd_media_keys_window_new               (void);
+void                  gsd_media_keys_window_set_action        (GsdMediaKeysWindow      *window,
+                                                               GsdMediaKeysWindowAction action);
+void                  gsd_media_keys_window_set_volume_muted  (GsdMediaKeysWindow      *window,
+                                                               gboolean                 muted);
+void                  gsd_media_keys_window_set_volume_level  (GsdMediaKeysWindow      *window,
+                                                               int                      level);
+gboolean              gsd_media_keys_window_is_valid          (GsdMediaKeysWindow      *window);
+
+G_END_DECLS
+
+#endif
-- 
1.6.5.1

